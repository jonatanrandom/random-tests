<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Controller</title>
<style>
  body { font-family:sans-serif; text-align:center; padding:2em; }
  input { font-size:1.2em; padding:0.3em; width:80%; max-width:300px; }
  button { font-size:1.2em; padding:0.4em 1em; margin-top:0.5em; }
  #status { margin-top:1em; color:green; }
  #uiToggleBtn {
    opacity: 0.3;
    position: fixed;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
  }
  .minimal-mode body {
    background-color: black;
    color: white;
  }
  .minimal-mode #peerId,
  .minimal-mode #connectBtn,
  .minimal-mode #modeBtn,
  .minimal-mode #status,
  .minimal-mode #tiltDisplay,
  .minimal-mode #angleDisplay,
  .minimal-mode h2 {
    display: none;
  }
</style>
</head>
<body>
<h2>controller</h2>
<input id="peerId" placeholder="Viewer ID">
<br>
<button id="connectBtn">Connect</button>
<br>
<button id="modeBtn">Change Mode</button>
<div id="status"></div>
<div id="tiltDisplay">Motion: 0.00 m/s²</div>
<div id="angleDisplay">Angle: 0.00°</div>
<button id="uiToggleBtn">Toggle UI</button>

<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script>
let peer = new Peer();
let conn;
let connected = false;
let currentMode = 'ungather'; // track current viewer mode

const status = document.getElementById('status');
const connectBtn = document.getElementById('connectBtn');
const peerInput = document.getElementById('peerId');
const modeBtn = document.getElementById('modeBtn');
const uiToggleBtn = document.getElementById('uiToggleBtn');
modeBtn.disabled = true;

connectBtn.onclick = () => {
  const id = peerInput.value.trim();
  if (!id) {
    alert("Please enter the viewer ID");
    return;
  }
  conn = peer.connect(id);
  conn.on('open', () => {
    connected = true;
    status.textContent = 'Connected!';
    modeBtn.disabled = false;
    enableTiltControl();
  });
  conn.on('error', err => {
    status.textContent = 'Connection failed: ' + err;
  });
};

// Manual override button
modeBtn.onclick = () => {
  if (connected && conn?.open) {
    const newMode = currentMode === 'gather' ? 'ungather' : 'gather';
    conn.send({ type: 'toggleGather', state: newMode });
    currentMode = newMode;
    status.textContent = 'Mode manually toggled to ' + newMode;
  }
};

function enableTiltControl() {
  // Request iOS permission if necessary
  if (typeof DeviceMotionEvent.requestPermission === 'function') {
    DeviceMotionEvent.requestPermission()
      .then(response => {
        if (response === 'granted') {
          window.addEventListener('devicemotion', handleMotion);
        } else {
          alert('Motion permission denied.');
        }
      })
      .catch(console.error);
  } else {
    window.addEventListener('devicemotion', handleMotion);
  }
}

let gatherTimer = null;
let ungatherTimer = null;
let moving = false;

function handleMotion(e) {
  // require an active open connection
  if (!connected || !conn || !conn.open) return;

  const linearAcc = e.acceleration;
  const gravityAcc = e.accelerationIncludingGravity;
  if (!linearAcc || !gravityAcc) return;

  // Compute total linear acceleration magnitude (without gravity)
  const total = Math.sqrt((linearAcc.x || 0) ** 2 + (linearAcc.y || 0) ** 2 + (linearAcc.z || 0) ** 2);

  // Use a smaller, realistic threshold (typical still noise ~0.05–0.3 m/s²)
  const threshold = 0.6; // movement threshold (m/s²)

  document.getElementById('tiltDisplay').textContent = `Motion: ${total.toFixed(2)} m/s²`;

  const isMoving = total > threshold;

  if (isMoving) {
    // device currently moving
    moving = true;

    // cancel any pending ungather timer
    if (ungatherTimer) {
      clearTimeout(ungatherTimer);
      ungatherTimer = null;
    }

    // start (or keep) a gather timer — only one at a time
    if (currentMode !== 'gather' && !gatherTimer) {
      gatherTimer = setTimeout(() => {
        // confirm movement still true before switching
        if (moving && currentMode !== 'gather') {
          currentMode = 'gather';
          try { conn.send({ type: 'toggleGather', state: 'gather' }); } catch (err) { /* ignore send errors */ }
          status.textContent = 'Motion detected: switched to gather';
        }
        gatherTimer = null;
      }, 100);
    }
  } else {
    // device currently still — estimate tilt angle
    const angle = Math.abs(Math.atan2(gravityAcc.y, Math.sqrt(gravityAcc.x * gravityAcc.x + gravityAcc.z * gravityAcc.z)) * (180 / Math.PI));
    document.getElementById('angleDisplay').textContent = `Angle: ${angle.toFixed(2)}°`;

    moving = false;

    // cancel any pending gather timer
    if (gatherTimer) {
      clearTimeout(gatherTimer);
      gatherTimer = null;
    }

    // only schedule ungather if nearly perfectly flat
    if (angle < 1.75 && currentMode !== 'ungather' && !ungatherTimer) {
      // capture angle for the callback so the message shows the measured value at schedule time
      const angleAtSchedule = angle;
      ungatherTimer = setTimeout(() => {
        // confirm stillness persists
        if (!moving && currentMode !== 'ungather') {
          currentMode = 'ungather';
          try { conn.send({ type: 'toggleGather', state: 'ungather' }); } catch (err) { /* ignore send errors */ }
          status.textContent = `Phone perfectly flat (angle ${angleAtSchedule.toFixed(2)}°): switched to ungather`;
        }
        ungatherTimer = null;
      }, 100);
    }
  }
}

let minimalMode = false;
uiToggleBtn.onclick = () => {
  minimalMode = !minimalMode;
  if (minimalMode) {
    document.documentElement.classList.add('minimal-mode');
  } else {
    document.documentElement.classList.remove('minimal-mode');
  }
};
</script>
</body>
</html>