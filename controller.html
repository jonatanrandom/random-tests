<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Controller</title>
<style>
  body { font-family:sans-serif; text-align:center; padding:2em; }
  input { font-size:1.2em; padding:0.3em; width:80%; max-width:300px; }
  button { font-size:1.2em; padding:0.4em 1em; margin-top:0.5em; }
  #status { margin-top:1em; color:green; }
  #uiToggleBtn {
    opacity: 0.3;
    position: fixed;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
  }
  .minimal-mode body {
    background-color: black;
    color: white;
  }
  .minimal-mode #peerId,
  .minimal-mode #connectBtn,
  .minimal-mode #modeBtn,
  .minimal-mode #status,
  .minimal-mode #tiltDisplay,
  .minimal-mode #angleDisplay,
  .minimal-mode h2 {
    display: none;
  }
</style>
</head>
<body>
<h2>controller</h2>
<input id="peerId" placeholder="Viewer ID">
<br>
<button id="connectBtn">Connect</button>
<br>
<button id="modeBtn">Change Mode</button>
<div id="status"></div>
<div id="tiltDisplay">Motion: 0.00 m/s²</div>
<div id="angleDisplay">Angle: 0.00°</div>
<button id="uiToggleBtn">Toggle UI</button>

<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script>
let peer = new Peer();
let conn;
let connected = false;
let currentMode = 'ungather'; // track current viewer mode

const status = document.getElementById('status');
const connectBtn = document.getElementById('connectBtn');
const peerInput = document.getElementById('peerId');
const modeBtn = document.getElementById('modeBtn');
const uiToggleBtn = document.getElementById('uiToggleBtn');
modeBtn.disabled = true;

connectBtn.onclick = () => {
  const id = peerInput.value.trim();
  if (!id) {
    alert("Please enter the viewer ID");
    return;
  }
  conn = peer.connect(id);
  conn.on('open', () => {
    connected = true;
    status.textContent = 'Connected!';
    modeBtn.disabled = false;
    enableTiltControl();
  });
  conn.on('error', err => {
    status.textContent = 'Connection failed: ' + err;
  });
};

// Manual override button
modeBtn.onclick = () => {
  if (connected && conn?.open) {
    const newMode = currentMode === 'gather' ? 'ungather' : 'gather';
    conn.send({ type: 'toggleGather', state: newMode });
    currentMode = newMode;
    status.textContent = 'Mode manually toggled to ' + newMode;
  }
};

function enableTiltControl() {
  // Request iOS permission if necessary
  if (typeof DeviceMotionEvent.requestPermission === 'function') {
    DeviceMotionEvent.requestPermission()
      .then(response => {
        if (response === 'granted') {
          window.addEventListener('devicemotion', handleMotion);
        } else {
          alert('Motion permission denied.');
        }
      })
      .catch(console.error);
  } else {
    window.addEventListener('devicemotion', handleMotion);
  }
}

let stillTimer = null;
let moving = false;

function handleMotion(e) {
  if (!connected || !conn?.open) return;

  const linearAcc = e.acceleration;
  const gravityAcc = e.accelerationIncludingGravity;
  if (!linearAcc || !gravityAcc) return;

  // Compute total linear acceleration magnitude (without gravity)
  const total = Math.sqrt(linearAcc.x ** 2 + linearAcc.y ** 2 + linearAcc.z ** 2);

  // Use a smaller, realistic threshold (typical still noise ~0.05–0.3 m/s²)
  const threshold = 0.6; // movement threshold (m/s²)

  document.getElementById('tiltDisplay').textContent = `Motion: ${total.toFixed(2)} m/s²`;

  const isMoving = total > threshold;

  if (isMoving) {
    moving = true;
    if (stillTimer) {
      clearTimeout(stillTimer);
      stillTimer = null;
    }
    if (currentMode !== 'gather') {
      // Start 300ms timer to switch to gather if motion persists
      stillTimer = setTimeout(() => {
        if (moving && currentMode !== 'gather') {
          currentMode = 'gather';
          conn.send({ type: 'toggleGather', state: 'gather' });
          status.textContent = 'Motion detected: switched to gather';
        }
        stillTimer = null;
      }, 300);
    }
  } else {
    // Estimate tilt angle: 0° = lying flat on its back
    const angle = Math.abs(Math.atan2(gravityAcc.y, Math.sqrt(gravityAcc.x * gravityAcc.x + gravityAcc.z * gravityAcc.z)) * (180 / Math.PI));
    document.getElementById('angleDisplay').textContent = `Angle: ${angle.toFixed(2)}°`;

    moving = false;

    if (stillTimer) {
      clearTimeout(stillTimer);
      stillTimer = null;
    }
    // Require nearly perfectly flat orientation (angle < 1.75°)
    if (angle < 1.75 && currentMode !== 'ungather') {
      // Start 300ms timer to switch to ungather if stillness persists
      stillTimer = setTimeout(() => {
        if (!moving && currentMode !== 'ungather') {
          currentMode = 'ungather';
          conn.send({ type: 'toggleGather', state: 'ungather' });
          status.textContent = `Phone perfectly flat (angle ${angle.toFixed(2)}°): switched to ungather`;
        }
        stillTimer = null;
      }, 300);
    }
  }
}

let minimalMode = false;
uiToggleBtn.onclick = () => {
  minimalMode = !minimalMode;
  if (minimalMode) {
    document.documentElement.classList.add('minimal-mode');
  } else {
    document.documentElement.classList.remove('minimal-mode');
  }
};
</script>
</body>
</html>