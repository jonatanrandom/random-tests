<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Viewer</title>
<style>
  html, body { height:100%; margin:0; background:#000; color:#fff; overflow:hidden; }
  #swarm {
    position: absolute;
    width: 100%;
    height: 100%;
    left: 0;
    top: 0;
  }
  .shape {
    position: absolute;
    filter: blur(20px);
    transition: left 0.15s ease-out, top 0.15s ease-out;
    background: #fff;
  }
  #info {
    position:fixed; top:10px; left:10px;
    font-family:sans-serif; font-size:16px;
    color: #fff;
  }
  #controls {
    position: fixed;
    bottom: 0;
    width: 100%;
    background: rgba(0,0,0,0);
    color: #fff;
    font-family: sans-serif;
    font-size: 16px;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    padding: 10px 0;
  }
  #controls label {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-size: 14px;
  }
  #controls input[type="range"] {
    margin-top: 5px;
    width: 80px;
    height: 4px;
  }
  #controls input[type="range"]::-webkit-slider-thumb {
    width: 10px;
    height: 10px;
  }
</style>
<style>
#singleBall {
  position: absolute;
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background: #fff;
  filter: blur(10px);
  opacity: 0.9;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  display: none;
}

.prompt {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  font-family: sans-serif;
  font-size: 24px;
  color: #fff;
  display: none;
  text-align: center;
}

#leftPrompt { left: 10%; }
#rightPrompt { right: 10%; }
</style>
</head>
<body>
<div id="swarm"></div>
<div id="singleBall"></div>
<div id="leftPrompt" class="prompt">Say hi to<br>Galaxy AI</div>
<div id="rightPrompt" class="prompt">Discover new<br>camera features</div>
<div id="info">Connecting...</div>

<div id="controls">
  <label for="sizeSlider">Size
    <input type="range" id="sizeSlider" min="0.5" max="2" step="0.1" value="1">
  </label>
  <label for="blurSlider">Blur
    <input type="range" id="blurSlider" min="0" max="50" step="1" value="20">
  </label>
  <button id="randomizeBtn">Randomize Shapes</button>
  <button id="modeBtn">Change Mode</button>
</div>

<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script>
const swarm = document.getElementById('swarm');
const info = document.getElementById('info');
const uniqueId = `viewer-${Math.random().toString(36).substr(2, 9)}`;
const peer = new Peer(uniqueId);

const shapes = [];
const motionCoeffs = [];
const basePositions = [];
const shapeCount = 15;

// Helper function to generate random number in range [min, max]
function randomRange(min, max) {
  return Math.random() * (max - min) + min;
}

// Create shapes with random styles and motion coefficients
for(let i = 0; i < shapeCount; i++) {
  const shape = document.createElement('div');
  shape.className = 'shape';
  shape.id = `shape${i}`;

  // Random size between 100 and 400 px
  const size = randomRange(150, 400);
  shape.style.width = `${size}px`;
  shape.style.height = `${size}px`;

  // Random initial position within window bounds
  const left = randomRange(0, window.innerWidth - size);
  const top = randomRange(0, window.innerHeight - size);
  shape.style.left = `${left}px`;
  shape.style.top = `${top}px`;

  // Store base position for independent movement
  basePositions.push({ x: left, y: top });

  // Background color always white (inverted)
  shape.style.background = `#fff`;

  // Random border-radius for varied shapes
  shape.style.borderRadius = `${randomRange(20, 80)}%`;

  // Random opacity between 0.3 and 1
  shape.style.opacity = randomRange(0.3, 1);

  swarm.appendChild(shape);
  shapes.push(shape);

  // Store motion coefficients for x and y (between 0.5 and 1.5)
  motionCoeffs.push({
    x: randomRange(0.5, 1.5),
    y: randomRange(0.5, 1.5),
  });
}

// Add slow random drifting offsets and phases for floating effect
const driftOffsets = [];
const driftPhases = [];
for(let i = 0; i < shapeCount; i++) {
  driftOffsets.push({ x: 0, y: 0 });
  driftPhases.push({
    x: Math.random() * 2 * Math.PI,
    y: Math.random() * 2 * Math.PI,
  });
}

let tiltData = { x: 0, y: 0 };

const sizeSlider = document.getElementById('sizeSlider');
const blurSlider = document.getElementById('blurSlider');
const randomizeBtn = document.getElementById('randomizeBtn');
const modeBtn = document.getElementById('modeBtn');
const singleBall = document.getElementById('singleBall');
const leftPrompt = document.getElementById('leftPrompt');
const rightPrompt = document.getElementById('rightPrompt');

let mode = 'swarm'; // can be 'swarm' or 'single'

modeBtn.addEventListener('click', () => {
  if (mode === 'swarm') {
    mode = 'single';
    swarm.style.display = 'none';
    singleBall.style.display = 'block';
    leftPrompt.style.display = 'block';
    rightPrompt.style.display = 'block';
  } else {
    mode = 'swarm';
    swarm.style.display = 'block';
    singleBall.style.display = 'none';
    leftPrompt.style.display = 'none';
    rightPrompt.style.display = 'none';
  }
});

sizeSlider.addEventListener('input', () => {
  const scaleValue = sizeSlider.value;
  shapes.forEach(shape => {
    shape.style.transform = `scale(${scaleValue})`;
  });
});

blurSlider.addEventListener('input', () => {
  const blurValue = blurSlider.value;
  shapes.forEach(shape => {
    shape.style.filter = `blur(${blurValue}px)`;
  });
});

randomizeBtn.addEventListener('click', () => {
  for(let i = 0; i < shapeCount; i++) {
    const shape = shapes[i];
    const size = shape.offsetWidth;
    const newLeft = randomRange(0, window.innerWidth - size);
    const newTop = randomRange(0, window.innerHeight - size);
    basePositions[i] = { x: newLeft, y: newTop };
    shape.style.left = `${newLeft}px`;
    shape.style.top = `${newTop}px`;

    // Reset drift offsets and phases on randomize
    driftOffsets[i] = { x: 0, y: 0 };
    driftPhases[i] = {
      x: Math.random() * 2 * Math.PI,
      y: Math.random() * 2 * Math.PI,
    };
  }
});

peer.on('open', id => {
  info.innerHTML = `<b>${id}</b>`;
});

peer.on('connection', conn => {
  info.textContent = 'Connected!';
conn.on('data', data => {
  if (data.type === 'tilt') {
    tiltData.x = data.x;
    tiltData.y = data.y;
  } else if (data.type === 'spike') {
    triggerSpikeEffect();
  }
});
  conn.on('close', () => {
    info.textContent = 'Connection lost. Reload both pages.';
  });
});

function triggerSpikeEffect() {
  shapes.forEach(shape => {
    const originalOpacity = parseFloat(shape.style.opacity) || 1;
    // Start at current opacity â†’ go to 1.0
    shape.style.transition = 'transform 0.5s ease-out, opacity 0.5s ease-out';
    shape.style.transform = 'scale(5)';
    shape.style.opacity = '1';

    // Then return slowly over 5 seconds
    setTimeout(() => {
      shape.style.transition = 'transform 5s ease-in, opacity 5s ease-in';
      shape.style.transform = 'scale(1)';
      shape.style.opacity = originalOpacity;
    }, 500);
  });
}

// Animation loop for slow floating drift and tilt displacement
let lastTimestamp = null;
function animate(timestamp) {
  if (!lastTimestamp) lastTimestamp = timestamp;
  const delta = (timestamp - lastTimestamp) / 1000; // seconds
  lastTimestamp = timestamp;

  if (mode === 'single') {
    const coeff = { x: 1, y: 1 };
    const scaleFactor = 1.5;
    const baseX = window.innerWidth / 2;
    const baseY = window.innerHeight / 2;
    const driftX = Math.sin(timestamp / 500) * 10;
    const driftY = Math.cos(timestamp / 500) * 10;

    let left = baseX + tiltData.x * coeff.x * scaleFactor + driftX;
    let top = baseY + tiltData.y * coeff.y * scaleFactor + driftY;

    const size = singleBall.offsetWidth;
    left = Math.min(window.innerWidth - size, Math.max(0, left));
    top = Math.min(window.innerHeight - size, Math.max(0, top));

    singleBall.style.left = `${left}px`;
    singleBall.style.top = `${top}px`;

    requestAnimationFrame(animate);
    return;
  }

  const driftAmplitude = 20; // max pixels drift amplitude
  const driftSpeed = 0.5; // radians per second

  for(let i = 0; i < shapeCount; i++) {
    const shape = shapes[i];
    const coeff = motionCoeffs[i];
    const size = shape.offsetWidth;
    const base = basePositions[i];

    // Update drift phases
    driftPhases[i].x += driftSpeed * delta;
    driftPhases[i].y += driftSpeed * delta;

    // Calculate drift offsets using sine wave for smooth floating
    driftOffsets[i].x = Math.sin(driftPhases[i].x) * driftAmplitude;
    driftOffsets[i].y = Math.sin(driftPhases[i].y) * driftAmplitude;

    // Scale input tilt by coefficients and a fixed factor for motion range
    const scaleFactor = 1.5; // adjust for more/less movement

    // Add small random drift for organic movement (same as original, but included here for tilt movement)
    const driftX = randomRange(-0.5, 0.5);
    const driftY = randomRange(-0.5, 0.5);

    let left = base.x + tiltData.x * coeff.x * scaleFactor + driftOffsets[i].x + driftX;
    let top = base.y + tiltData.y * coeff.y * scaleFactor + driftOffsets[i].y + driftY;

    // Clamp positions within window bounds
    left = Math.min(window.innerWidth - size, Math.max(0, left));
    top = Math.min(window.innerHeight - size, Math.max(0, top));

    shape.style.left = `${left}px`;
    shape.style.top = `${top}px`;
  }

  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
</script>
</body>
</html>