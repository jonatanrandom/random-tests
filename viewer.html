<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Dappled Light Simulation</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
    }
    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }
    .ui {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      color: white;
      font-family: sans-serif;
      font-size: 12px;
      line-height: 1.4;
      background: rgba(0, 0, 0, 0.4);
      padding: 6px 8px;
      border-radius: 4px;
    }
    .ui p {
      margin: 4px 0;
    }
    .ui input[type=range] {
      width: 160px;
    }
    .ui button {
      margin-top: 4px;
      font-size: 11px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: none;
      border-radius: 3px;
      padding: 3px 6px;
      cursor: pointer;
      display: block;
    }
    .ui button:hover {
      background: rgba(255, 255, 255, 0.25);
    }
  </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script>
    let peer = new Peer();
    let borderMargin = 90; // adjustable border width to keep blobs away from edges

    peer.on('connection', conn => {
      conn.on('data', data => {
        if (data.type === 'toggleGather') {
          if (data.state === 'gather' && !gathering) {
            gathering = true;
          } else if (data.state === 'ungather' && gathering) {
            gathering = false;
            for (let s of spots) {
              s.targetX = random(borderMargin, width - borderMargin);
              s.targetY = random(borderMargin, height - borderMargin);
              s.gatherInitialized = false; // reset gather state for next time
            }
          }
        }
      });
    });
    // Show viewer ID in UI
    peer.on('open', id => {
      let idElement = document.getElementById('peerId');
      if (idElement) idElement.textContent = id;
    });
  </script>

  <script>
    let spots = [];
    let numSpots = 120;
    let windOffset = 0;
    let numSpotsSlider, sizeSlider;
    let lastNumSpots = numSpots;
    let lastMaxSize = 90;

    let gathering = false;
    let gatherSpeed = 0.05; // how fast the spots move toward center

    let collisionEase = 1.0; // starts at full strength

    let canvasScale = 1.0;
    let scaleSlider;

    function setup() {
      createCanvas(windowWidth, windowHeight);
      noStroke();

      // UI container div
      let uiDiv = createDiv().class('ui');
      let controlsDiv = createDiv().parent(uiDiv);

      createP(`<span id="peerId">Loading...</span>`).parent(controlsDiv);

      createP('Blobs').parent(controlsDiv);
      numSpotsSlider = createSlider(20, 300, numSpots, 1).parent(controlsDiv);

      createP('Size').parent(controlsDiv);
      sizeSlider = createSlider(30, 200, 90, 1).parent(controlsDiv);

      createP('Scale').parent(controlsDiv);
      scaleSlider = createSlider(0.1, 2.0, 1.0, 0.01).parent(controlsDiv);

      let hideUIButton = createButton('Hide UI').parent(uiDiv);
      hideUIButton.mousePressed(() => {
        if (controlsDiv.style('display') === 'none') {
          controlsDiv.style('display', 'block');
          hideUIButton.html('Hide UI');
        } else {
          controlsDiv.style('display', 'none');
          hideUIButton.html('Show UI');
        }
      });

      let gatherButton = createButton('Gather').parent(uiDiv);
      gatherButton.mousePressed(() => {
        gathering = !gathering;
        gatherButton.html(gathering ? 'Ungather' : 'Gather');

        // When un-gathering, gently spread blobs back out
        if (!gathering) {
          for (let s of spots) {
            s.targetX = random(borderMargin, width - borderMargin);
            s.targetY = random(borderMargin, height - borderMargin);
            s.gatherInitialized = false; // reset gather state for next time
          }
        }
      });

      regenerateSpots();
    }

    function regenerateSpots() {
      spots = [];
      const newNum = numSpotsSlider.value();
      const maxSize = sizeSlider.value();
      for (let i = 0; i < newNum; i++) {
        spots.push({
          x: random(width),
          y: random(height),
          baseX: random(width),
          baseY: random(height),
          size: random(30, maxSize),
          alpha: random(100, 200),
          cluster: floor(random(5)),
          noiseSeed: random(1000),
          speed: random(0.0009, 0.01),
          dimState: { dimming: false, dimTimer: 0, dimTarget: 1 },
          gatherDelay: random(0, 300) // delay in milliseconds before starting gather
        });
      }
    }

    function draw() {
      if (numSpots !== numSpotsSlider.value() || lastMaxSize !== sizeSlider.value()) {
        numSpots = numSpotsSlider.value();
        lastMaxSize = sizeSlider.value();
        regenerateSpots();
      }

      clear(); // changed from background(0) to clear()

      canvasScale = scaleSlider ? scaleSlider.value() : 1.0;

      push();
      scale(canvasScale);
      translate(
        (width / 2 / canvasScale) - (width / 2),
        (height / 2 / canvasScale) - (height / 2)
      );

      blendMode(ADD);
      windOffset += 0.001;

      if (gathering) {
        let currentTime = millis();
        for (let s of spots) {
          // If we just started gathering again, reset new gather start times
          if (!s.hasOwnProperty('gatherInitialized') || !s.gatherInitialized) {
            s.gatherStartTime = currentTime + s.gatherDelay;
            s.gatherInitialized = true;
          }
          if (currentTime < s.gatherStartTime) continue; // wait until its delay has passed

          let targetX = width / 2;
          let targetY = height / 2;
          let dx = targetX - s.baseX;
          let dy = targetY - s.baseY;

          // Add soft organic noise
          let n = noise(s.noiseSeed + frameCount * 0.01);
          let offsetX = map(n, 0, 1, -20, 20);
          let offsetY = map(n, 0, 1, -20, 20);

          // Move smoothly toward center based on gatherSpeed
          s.baseX += dx * gatherSpeed + offsetX * 0.01;
          s.baseY += dy * gatherSpeed + offsetY * 0.01;
        }
      }

      if (!gathering) {
        for (let s of spots) {
          if (s.targetX && s.targetY) {
            let dx = s.targetX - s.baseX;
            let dy = s.targetY - s.baseY;
            s.baseX += dx * gatherSpeed * 0.5;
            s.baseY += dy * gatherSpeed * 0.5;

            // Stop movement when near target
            if (abs(dx) < 1 && abs(dy) < 1) {
              s.targetX = null;
              s.targetY = null;
            }
          }
        }
      }

      for (let s of spots) {
        // Occasionally trigger dimming using new time-based interpolation
        if (!s.dimState.dimming && random() < 0.0005) {
          s.dimState.dimming = true;
          s.dimState.timer = 0;
          s.dimState.durationOut = random(0.4, 0.6);
          s.dimState.durationHold = random(0.5, 1.5);
          s.dimState.durationIn = random(0.2, 0.4);
          s.dimState.startAlpha = s.alpha;
          s.dimState.targetAlpha = s.alpha * random(0.1, 0.4); // how dark it gets
        }

        if (s.dimState.dimming) {
          s.dimState.timer += deltaTime / 1000.0; // convert ms to seconds
          let t = s.dimState.timer;
          let fadeOutEnd = s.dimState.durationOut;
          let holdEnd = fadeOutEnd + s.dimState.durationHold;
          let fadeInEnd = holdEnd + s.dimState.durationIn;

          if (t < fadeOutEnd) {
            // Fade out phase
            let progress = t / fadeOutEnd;
            s.alpha = lerp(s.dimState.startAlpha, s.dimState.targetAlpha, progress);
          } else if (t < holdEnd) {
            // Stay dimmed
            s.alpha = s.dimState.targetAlpha;
          } else if (t < fadeInEnd) {
            // Fade back in
            let progress = (t - holdEnd) / s.dimState.durationIn;
            s.alpha = lerp(s.dimState.targetAlpha, s.dimState.startAlpha, progress);
          } else {
            // Done
            s.dimState.dimming = false;
            s.alpha = s.dimState.startAlpha;
          }
        }
      }

       let windStrength = map(noise(frameCount * 0.005), 0, 1, 0.2, 1.2);
       let windAngle = noise(frameCount * 0.007) * TWO_PI;
       let waveX = Math.cos(windAngle) * 20 * windStrength;
       let waveY = Math.sin(windAngle) * 20 * windStrength;

      // Smoothly ease in collisions when ungathering
      let targetCollisionEase = gathering ? 0.0 : 1.0;
      collisionEase = lerp(collisionEase, targetCollisionEase, 0.02);

      // Soft collision logic to prevent overlapping
      if (!gathering) {
        for (let i = 0; i < spots.length; i++) {
          for (let j = i + 1; j < spots.length; j++) {
            let s1 = spots[i];
            let s2 = spots[j];
            let dx = s2.baseX - s1.baseX;
            let dy = s2.baseY - s1.baseY;
            let distSq = dx * dx + dy * dy;
            let minDist = (s1.size + s2.size) * 0.6;
            if (distSq < minDist * minDist) {
              let dist = sqrt(distSq) || 0.001;
              let overlap = (minDist - dist) * 0.6 * collisionEase; // eased collision strength
              let nx = dx / dist;
              let ny = dy / dist;
              s1.baseX -= nx * overlap;
              s1.baseY -= ny * overlap;
              s2.baseX += nx * overlap;
              s2.baseY += ny * overlap;
            }
          }
        }
      }

      for (let s of spots) {
        let radius = s.size * 0.5;
        if (s.baseX < borderMargin + radius) s.baseX = borderMargin + radius;
        if (s.baseX > width - borderMargin - radius) s.baseX = width - borderMargin - radius;
        if (s.baseY < borderMargin + radius) s.baseY = borderMargin + radius;
        if (s.baseY > height - borderMargin - radius) s.baseY = height - borderMargin - radius;
      }

      let t = frameCount * 0.045; // controls speed of wave travel

      for (let s of spots) {
        let nX = noise(s.noiseSeed + frameCount * s.speed, s.cluster * 0.5);
        let nY = noise(s.noiseSeed + 100 + frameCount * s.speed, s.cluster * 0.5);

        // Clustered organic motion
        let breezeX = map(nX, 0, 1, -100, 100);
        let breezeY = map(nY, 0, 1, -100, 100);

        // No tilt influence
        let x = s.baseX + breezeX;
        let y = s.baseY + breezeY;

        let phase = ((s.baseX + s.baseY) / (width + height)) * TWO_PI;
        let wave = sin(t - phase) * 1.0; // wave passes diagonally
        let waveStrength = map(noise(t * 0.05), 0, 1, 0.5, 1.5);
        let waveDisplacement = wave * 25 * waveStrength;
        let waveAngle = radians(45); // diagonal from bottom-left to top-right
        let waveX = cos(waveAngle) * waveDisplacement;
        let waveY = -sin(waveAngle) * waveDisplacement;

        x += waveX;
        y += waveY;

        // Draw soft organic patch
        drawOrganicSpot(x, y, s.size, s.alpha, s.noiseSeed);
      }

      pop();
    }

function triggerGather() {
  gathering = true;
  gatherStartTime = millis();
}

function drawOrganicSpot(x, y, r, alpha, seed) {
  let ctx = drawingContext;
  ctx.save();
  ctx.translate(x, y);

  // Apply global rotation (for all blobs)
  let globalRotation = radians(10); // e.g. slight diagonal rotation
  ctx.rotate(globalRotation);

  // Apply directional stretch (optional)
  let stretchAngle = radians(40); // direction of sunlight stretch
  ctx.rotate(stretchAngle);
  ctx.scale(1.3, 0.9); // stretch along the chosen direction
  ctx.rotate(-stretchAngle);

  // Gradient and blur
  let distortionX = map(noise(seed + 0.5), 0, 1, 0.85, 1.15);
  let distortionY = map(noise(seed + 500 + 0.5), 0, 1, 0.85, 1.15);
  let shimmer = map(noise(seed + 1000 + frameCount * 0.01), 0, 1, 0.7, 1);
  let gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, r * 3.6);
  gradient.addColorStop(0, `rgba(255,255,255,${(alpha / 255) * shimmer})`);
  gradient.addColorStop(0.3, `rgba(255,255,255,${(alpha / 255) * 0.6 * shimmer})`);
  gradient.addColorStop(0.7, `rgba(255,255,255,${(alpha / 255) * 0.2 * shimmer})`);
  gradient.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = gradient;
  let blurAmount = 17 * canvasScale; // blur increases when zooming in, decreases when zooming out
  ctx.filter = `blur(${blurAmount}px)`;

  // Organic blob shape
  const points = 24;
  ctx.beginPath();
  for (let i = 0; i <= points; i++) {
    let angle = (i / points) * TWO_PI;
    let noiseVal = noise(seed + Math.cos(angle) * 0.8, seed + Math.sin(angle) * 0.8);
    let radius = r * map(noiseVal, 0, 1, 0.5, 1.4);
    let px = radius * distortionX * Math.cos(angle);
    let py = radius * distortionY * Math.sin(angle);
    if (i === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  }
  ctx.closePath();
  ctx.fill();

  ctx.filter = 'none';
  ctx.restore();
}

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>
</html>