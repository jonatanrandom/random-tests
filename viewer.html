<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Viewer</title>
<style>
  html, body { height:100%; margin:0; background:#000; color:#fff; overflow:hidden; }
  #swarm {
    position: absolute;
    width: 100%;
    height: 100%;
    left: 0;
    top: 0;
  }
  .shape {
    position: absolute;
    filter: blur(20px);
    transition: left 0.15s ease-out, top 0.15s ease-out;
    background: #fff;
  }
  #info {
    position:fixed; top:10px; left:10px;
    font-family:sans-serif; font-size:16px;
    color: #fff;
  }
  #controls {
    position: fixed;
    bottom: 0;
    width: 100%;
    background: rgba(0,0,0,0);
    color: #fff;
    font-family: sans-serif;
    font-size: 16px;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    padding: 10px 0;
  }
  #controls label {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-size: 14px;
  }
  #controls input[type="range"] {
    margin-top: 5px;
    width: 80px;
    height: 4px;
  }
  #controls input[type="range"]::-webkit-slider-thumb {
    width: 10px;
    height: 10px;
  }
  #randomizeBtn {
    padding: 5px 10px;
    font-size: 16px;
    cursor: pointer;
  }
</style>
</head>
<body>
<div id="swarm"></div>
<div id="info">Connecting...</div>

<div id="controls">
  <label for="sizeSlider">Size
    <input type="range" id="sizeSlider" min="0.5" max="2" step="0.1" value="1">
  </label>
  <label for="blurSlider">Blur
    <input type="range" id="blurSlider" min="0" max="50" step="1" value="20">
  </label>
  <button id="randomizeBtn">Randomize Shapes</button>
</div>

<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script>
const swarm = document.getElementById('swarm');
const info = document.getElementById('info');
const peer = new Peer();

const shapes = [];
const motionCoeffs = [];
const basePositions = [];
const shapeCount = 15;

// Helper function to generate random number in range [min, max]
function randomRange(min, max) {
  return Math.random() * (max - min) + min;
}

// Create shapes with random styles and motion coefficients
for(let i = 0; i < shapeCount; i++) {
  const shape = document.createElement('div');
  shape.className = 'shape';
  shape.id = `shape${i}`;

  // Random size between 100 and 400 px
  const size = randomRange(150, 400);
  shape.style.width = `${size}px`;
  shape.style.height = `${size}px`;

  // Random initial position within window bounds
  const left = randomRange(0, window.innerWidth - size);
  const top = randomRange(0, window.innerHeight - size);
  shape.style.left = `${left}px`;
  shape.style.top = `${top}px`;

  // Store base position for independent movement
  basePositions.push({ x: left, y: top });

  // Background color always white (inverted)
  shape.style.background = `#fff`;

  // Random border-radius for varied shapes
  shape.style.borderRadius = `${randomRange(20, 80)}%`;

  // Random opacity between 0.3 and 1
  shape.style.opacity = randomRange(0.3, 1);

  swarm.appendChild(shape);
  shapes.push(shape);

  // Store motion coefficients for x and y (between 0.5 and 1.5)
  motionCoeffs.push({
    x: randomRange(0.5, 1.5),
    y: randomRange(0.5, 1.5),
  });
}

// Add slow random drifting offsets and phases for floating effect
const driftOffsets = [];
const driftPhases = [];
for(let i = 0; i < shapeCount; i++) {
  driftOffsets.push({ x: 0, y: 0 });
  driftPhases.push({
    x: Math.random() * 2 * Math.PI,
    y: Math.random() * 2 * Math.PI,
  });
}

let tiltData = { x: 0, y: 0 };

const sizeSlider = document.getElementById('sizeSlider');
const blurSlider = document.getElementById('blurSlider');
const randomizeBtn = document.getElementById('randomizeBtn');

sizeSlider.addEventListener('input', () => {
  const scaleValue = sizeSlider.value;
  shapes.forEach(shape => {
    shape.style.transform = `scale(${scaleValue})`;
  });
});

blurSlider.addEventListener('input', () => {
  const blurValue = blurSlider.value;
  shapes.forEach(shape => {
    shape.style.filter = `blur(${blurValue}px)`;
  });
});

randomizeBtn.addEventListener('click', () => {
  for(let i = 0; i < shapeCount; i++) {
    const shape = shapes[i];
    const size = shape.offsetWidth;
    const newLeft = randomRange(0, window.innerWidth - size);
    const newTop = randomRange(0, window.innerHeight - size);
    basePositions[i] = { x: newLeft, y: newTop };
    shape.style.left = `${newLeft}px`;
    shape.style.top = `${newTop}px`;

    // Reset drift offsets and phases on randomize
    driftOffsets[i] = { x: 0, y: 0 };
    driftPhases[i] = {
      x: Math.random() * 2 * Math.PI,
      y: Math.random() * 2 * Math.PI,
    };
  }
});

peer.on('open', id => {
  info.innerHTML = `<b>${id}</b>`;
});

peer.on('connection', conn => {
  info.textContent = 'Connected!';
  conn.on('data', data => {
    const { x, y } = data;
    tiltData.x = x;
    tiltData.y = y;
  });
  conn.on('close', () => {
    info.textContent = 'Connection lost. Reload both pages.';
  });
});

// Animation loop for slow floating drift and tilt displacement
let lastTimestamp = null;
function animate(timestamp) {
  if (!lastTimestamp) lastTimestamp = timestamp;
  const delta = (timestamp - lastTimestamp) / 1000; // seconds
  lastTimestamp = timestamp;

  const driftAmplitude = 20; // max pixels drift amplitude
  const driftSpeed = 0.5; // radians per second

  for(let i = 0; i < shapeCount; i++) {
    const shape = shapes[i];
    const coeff = motionCoeffs[i];
    const size = shape.offsetWidth;
    const base = basePositions[i];

    // Update drift phases
    driftPhases[i].x += driftSpeed * delta;
    driftPhases[i].y += driftSpeed * delta;

    // Calculate drift offsets using sine wave for smooth floating
    driftOffsets[i].x = Math.sin(driftPhases[i].x) * driftAmplitude;
    driftOffsets[i].y = Math.sin(driftPhases[i].y) * driftAmplitude;

    // Scale input tilt by coefficients and a fixed factor for motion range
    const scaleFactor = 1.5; // adjust for more/less movement

    // Add small random drift for organic movement (same as original, but included here for tilt movement)
    const driftX = randomRange(-0.5, 0.5);
    const driftY = randomRange(-0.5, 0.5);

    let left = base.x + tiltData.x * coeff.x * scaleFactor + driftOffsets[i].x + driftX;
    let top = base.y + tiltData.y * coeff.y * scaleFactor + driftOffsets[i].y + driftY;

    // Clamp positions within window bounds
    left = Math.min(window.innerWidth - size, Math.max(0, left));
    top = Math.min(window.innerHeight - size, Math.max(0, top));

    shape.style.left = `${left}px`;
    shape.style.top = `${top}px`;
  }

  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
</script>
</body>
</html>